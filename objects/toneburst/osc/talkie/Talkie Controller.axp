<patch-1.0 appVersion="1.0.10">
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="Volume" x="420" y="42">
      <params>
         <frac32.u.map name="value" value="51.0"/>
      </params>
      <attribs/>
   </obj>
   <patcher type="patch/patcher" uuid="189f746e-575c-4ffd-98c2-d226787f24f2" name="Energy" x="112" y="126">
      <params>
         <frac32.u.map name="Value" value="64.0"/>
      </params>
      <attribs/>
      <subpatch appVersion="1.0.10">
         <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="Value" x="70" y="84">
            <params>
               <frac32.u.map name="value" onParent="true" value="0.0"/>
            </params>
            <attribs/>
         </obj>
         <patchobj type="patch/object" uuid="96da9a47-7d67-452e-96ad-ecfa2ac1c0f8" name="Param Max__" x="154" y="84">
            <params>
               <int32 name="max" value="255"/>
            </params>
            <attribs/>
            <object id="patch/object" uuid="96da9a47-7d67-452e-96ad-ecfa2ac1c0f8">
               <sDescription>greater than</sDescription>
               <author>toneburst</author>
               <license>BSD</license>
               <helpPatch>math.axh</helpPatch>
               <inlets>
                  <frac32.positive name="val"/>
               </inlets>
               <outlets>
                  <int32.positive name="int" description="integer positive result"/>
               </outlets>
               <displays/>
               <params>
                  <int32 name="max">
                     <MinValue i="0"/>
                     <MaxValue i="134217727"/>
                  </int32>
               </params>
               <attribs/>
               <includes/>
               <code.declaration><![CDATA[


// Scale input to range out_min > out_max
// Input range hard-coded to 0 > 134217727 (27 bits) for frac32.pos inlets / frac32.u.map params
// WONT'T Work with bipolar input!
__attribute__ ( ( always_inline ) ) __STATIC_INLINE int32_t range_pos(int32_t val, int32_t out_max) {
	return (int32_t)(float)val * (float)out_max / 0x07FFFFFF;
};

]]></code.declaration>
               <code.krate><![CDATA[

outlet_int = range_pos(__USAT(inlet_val, 27), param_max);

]]></code.krate>
            </object>
         </patchobj>
         <obj type="patch/outlet i" uuid="aae2176b26209e34e4fdeba5edb1ace82d178655" name="outlet_1" x="252" y="84">
            <params/>
            <attribs/>
         </obj>
         <nets>
            <net>
               <source obj="Value" outlet="out"/>
               <dest obj="Param Max__" inlet="val"/>
            </net>
            <net>
               <source obj="Param Max__" outlet="int"/>
               <dest obj="outlet_1" inlet="outlet"/>
            </net>
         </nets>
         <settings>
            <subpatchmode>no</subpatchmode>
         </settings>
         <notes><![CDATA[]]></notes>
      </subpatch>
   </patcher>
   <obj type="math/*" uuid="3ac307b9f782049739ed62504081b96d580ea336" name="*_1" x="504" y="126">
      <params/>
      <attribs/>
   </obj>
   <obj type="audio/out stereo" uuid="a1ca7a567f535acc21055669829101d3ee7f0189" name="out_1" x="574" y="126">
      <params/>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="2e3b980b-4415-428f-b6ca-29f283183066" name="Talkie Voiced Source" x="350" y="140">
      <params>
         <frac32.u.map name="wave" value="0.0"/>
         <frac32.u.map name="oct" value="32.0"/>
         <bool32.tgl name="pitch" value="1"/>
         <int32 name="pmode" value="2"/>
         <frac32.u.map name="gliss" value="32.0"/>
         <frac32.u.map name="crush" value="0.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="2e3b980b-4415-428f-b6ca-29f283183066">
         <sDescription>Talkie Synth</sDescription>
         <author>toneburst</author>
         <license>BSD</license>
         <helpPatch>math.axh</helpPatch>
         <inlets>
            <int32.positive name="synthEnergy" description="synth energy"/>
            <int32.bipolar name="synthPeriod"/>
            <frac32.positive name="oct" description="octave transpose"/>
            <bool32 name="pitch" description="while true, override pitch set with &apos;synthPeriod&apos; inlet with MIDI note value at &apos;note&apos; inlet"/>
            <frac32.bipolar name="note" description="midi note in"/>
            <frac32.positive name="crush" description="bit-crush"/>
            <frac32.positive name="gliss" description="glissando"/>
         </inlets>
         <outlets>
            <frac32buffer.bipolar name="out"/>
            <frac32.bipolar name="debug"/>
         </outlets>
         <displays/>
         <params>
            <frac32.u.map name="wave" description="crossfade between different CHIRP waveforms"/>
            <frac32.u.map name="oct" description="octave"/>
            <bool32.tgl name="pitch" description="override pitch set by &apos;synthEnergy&apos; inlet with value at inlet &apos;note&apos; when true"/>
            <int32 name="pmode" description="pitch-shift mode when &apos;pitch&apos; inlet true">
               <MinValue i="1"/>
               <MaxValue i="2"/>
            </int32>
            <frac32.u.map name="gliss" description="glissando"/>
            <frac32.u.map name="crush" description="bit-crush"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[

///////////////////
///////////////////
//// VARIABLES ////
///////////////////
///////////////////

///////////////
// Constants //
///////////////

const uint8_t tmsEnergy[0x10] = {0x00,0x02,0x03,0x04,0x05,0x07,0x0a,0x0f,0x14,0x20,0x29,0x39,0x51,0x72,0xa1,0xff};
const uint8_t tmsPeriod[0x40] = {0x00,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2D,0x2F,0x31,0x33,0x35,0x36,0x39,0x3B,0x3D,0x3F,0x42,0x45,0x47,0x49,0x4D,0x4F,0x51,0x55,0x57,0x5C,0x5F,0x63,0x66,0x6A,0x6E,0x73,0x77,0x7B,0x80,0x85,0x8A,0x8F,0x95,0x9A,0xA0};

#define CHIRP_SIZE 52
const int8_t chirpTables[3][CHIRP_SIZE] = {
	// TI 2801 CHIRP
	{0x00,0x2b,0xd4,0x33,0xb3,0x12,0x25,0x14,0x02,0xe2,0xc6,0x03,0x60,0x5b,0x05,0x0f,0x26,0xfc,0xa6,0xa5,0xd6,0xdd,0xdd,0xfd,0x25,0x2b,0x23,0x22,0x0f,0xff,0xf8,0xef,0xed,0xef,0xf7,0xf7,0xfa,0x01,0x04,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	// TI 2802 CHIRP
	{0x00,0xa5,0xbd,0xee,0x34,0x73,0x7e,0x3d,0xe8,0xea,0x34,0x24,0xd1,0x01,0x13,0xc3,0x0c,0xd2,0xe7,0xdd,0xd9,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	// TI LATER CHIRP
	{0x00,0x03,0x0f,0x28,0x4c,0x6c,0x71,0x50,0x25,0x26,0x4c,0x44,0x1a,0x32,0x3b,0x13,0x37,0x1a,0x25,0x1f,0x1d,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
	// TI LATER CHIRP
	{0x00,0x03,0x0f,0x28,0x4c,0x6c,0x71,0x50,0x25,0x26,0x4c,0x44,0x1a,0x32,0x3b,0x13,0x37,0x1a,0x25,0x1f,0x1d,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
};

// 8000Hz cycle counts to MIDI notes (error increases with frequency)
// MIDI Notes C2 (MIDI note #36) - C4 (#60)
const int8_t midiNotes[25] = {122,116,109,103,97,92,87,82,77,73,69,65,61,58,55,51,49,46,43,41,38,36,34,32,31};
// Transpose table for transpose mode 1
const int8_t midiTranspose[25] = {61,55,48,42,36,31,26,21,16,12,8,4,0,-3,-6,-10,-12,-15,-18,-20,-23,-25,-27,-29,-30};

///////////////////////////
// Synth State Variables //
///////////////////////////

// Synth period (no. 8kHz cycles)
uint8_t synthPeriod;
// Synth volume
uint16_t synthEnergy;
// Frame frequency
uint8_t periodCounter;

/////////////////
// Slew-states //
/////////////////

int32_t energySlewState;
int32_t oscPeriodSlewState;

///////////////////
// Params/Inlets //
///////////////////

bool voiced;
uint32_t wave;
uint32_t octave;
uint8_t oscPeriod;
uint32_t crush;
uint16_t noiseMix;
uint32_t gliss;
uint8_t chirp;
int8_t midiNote;

/////////////
// Samples //
/////////////

int32_t sample;
int8_t extOsc;

//////////////
// Counters //
//////////////

uint8_t renderCounter;
uint8_t renderInterval;
int8_t midiPeriod;

///////////////////
///////////////////
//// FUNCTIONS ////
///////////////////
///////////////////

//////////////////
// Render Audio //
//////////////////

int8_t tk_renderVoiced() {
	// Generate voiced source
	static int16_t voicedSource;

	if (periodCounter < oscPeriod) {
		periodCounter++;
	} else {
		periodCounter = 0;
	}
	if (periodCounter < CHIRP_SIZE) {
		voicedSource = ((chirpTables[chirp][periodCounter]) * (uint32_t) synthEnergy) >> 8;
	} else {
		voicedSource = 0;
	}
	return voicedSource;
}

///////////////////////
// Utility Functions //
///////////////////////

// Scale input to range out_min > out_max
__attribute__ ( ( always_inline ) ) __STATIC_INLINE int32_t range_pos(int32_t val, int32_t out_min, int32_t out_max) {
	float x = (float)val;
	float outMin = (float)out_min;
	float outMax = (float)out_max;
	return (int32_t)(x * (outMax - outMin) / 0x07FFFFFF + outMin);
};

// 8-Bit clamp val to range min > max
__attribute__ ( ( always_inline ) ) __STATIC_INLINE int8_t clamp8(int8_t val, int8_t min, int8_t max) {
	return (val <= min) ? min : (val >= max) ? max : val;
}

// 16-bit xfade (adapted from Factory xfade object)
__attribute__ ( ( always_inline ) ) __STATIC_INLINE int16_t xfade16(int16_t a, int16_t b, uint16_t x) {
	int16_t ccompl = (1 << 15) - x;
	int32_t result = (int32_t)b * x;
	result += (int32_t)a * ccompl;
	return result >> 16;
}

// Slew function, with pointer to state variable
__attribute__ ( ( always_inline ) ) __STATIC_INLINE int32_t slew(int32_t target, int32_t *state, int32_t slewTime, bool enable) {
	if (enable && slewTime > 0) {
		*state = ___SMMLA(*state - target, (-1 << 26) + (slewTime >> 1), *state);
		return *state;
	} else {
		*state = target;
		return target;
	};
};

]]></code.declaration>
         <code.init><![CDATA[

// Counters (count S-Rate cycles)
renderCounter = 0;
// S-Rate cycle periods for sample-calculate function
renderInterval = 6;

// Calculated output sample value
sample = 0;
// External audio input sample
extOsc = 0;

// Inlets/Param values
wave = 0;
octave = 0;
oscPeriod = 0;
crush = 9;
gliss = 0;
chirp = 0;

]]></code.init>
         <code.krate><![CDATA[

// Synth energy and period, with slew
synthEnergy = __USAT(inlet_synthEnergy, 16);//slew(__USAT(inlet_synthEnergy, 16)<<24, &energySlewState, smear, true)>>24;
synthPeriod = tmsPeriod[__USAT(inlet_synthPeriod, 8)];

///////////////////
// Params/Inlets //
///////////////////

// Wave-select
//wave = param_wave >> 25;
// Wave index 0 - 3
//uint8_t waveIndex = param_wave >> 25;
//uint16_t wavePos = (param_wave << 5) * 3;

// Bitcrush
crush = range_pos(__USAT(param_crush + inlet_crush, 27), 1, 7);
// Glissando
gliss = __USAT(param_gliss + inlet_gliss, 27);
// Octave
octave = range_pos(__USAT(param_oct + inlet_oct, 27), 0, 2);

// Transpose/set period of voiced source
// if boolean inlet 'pitch' true
if(inlet_pitch || param_pitch) {
	// MIDI note number, clamped to range, scaled
	midiNote = clamp8(inlet_note >> 21, -40, -16) + 40;
	// Mode 1: transpose
	if(param_pmode == 1) {
		oscPeriod = synthPeriod + midiTranspose[midiNote];		
	// Mode 2: set period from Note inlet (Vocoder mode)
	} else if(param_pmode == 2) {
		oscPeriod = midiNotes[midiNote];
	}
} else {
	oscPeriod = synthPeriod;
}
oscPeriod = slew(oscPeriod << 24, &oscPeriodSlewState, gliss, TRUE) >> 24;

// Switch sample-rate for low/high/mid octaves
switch(octave) {
	case 0  :
		renderInterval = 12;
		break;
	case 2  :
		renderInterval = 3;
		break;
	default :
		renderInterval = 6;
}

// Chirp table
chirp = 0;//attr_wave;

/////////////////
// Render Loop //
/////////////////

for(uint8_t j = 0; j < BUFSIZE; j++) {

	///////////////////
	// Render Sample //
	///////////////////
	
	if(renderCounter == 0) {
		sample = (tk_renderVoiced() >> crush) << crush;
	}
	
	// Increment render counter
	renderCounter = (renderCounter < (renderInterval - 1)) ? renderCounter + 1 : 0;
	
	// Write samples to output buffer (27 bits)
	outlet_out[j] = sample << 19;
}

]]></code.krate>
      </object>
   </patchobj>
   <obj type="midi/in/keyb mod" uuid="abcd509d15e7d13d5381203fd2b4d0ac6fe57bb3" name="keyb_1" x="238" y="196">
      <params/>
      <attribs/>
   </obj>
   <patcher type="patch/patcher" uuid="a6160cfb-6e4e-422e-b683-f15d625929fe" name="Period" x="112" y="252">
      <params>
         <frac32.u.map name="Value" value="61.0"/>
      </params>
      <attribs/>
      <subpatch appVersion="1.0.10">
         <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="Value" x="70" y="84">
            <params>
               <frac32.u.map name="value" onParent="true" value="0.0"/>
            </params>
            <attribs/>
         </obj>
         <patchobj type="patch/object" uuid="96da9a47-7d67-452e-96ad-ecfa2ac1c0f8" name="Param Max__" x="154" y="84">
            <params>
               <int32 name="max" value="51"/>
            </params>
            <attribs/>
            <object id="patch/object" uuid="96da9a47-7d67-452e-96ad-ecfa2ac1c0f8">
               <sDescription>greater than</sDescription>
               <author>toneburst</author>
               <license>BSD</license>
               <helpPatch>math.axh</helpPatch>
               <inlets>
                  <frac32.positive name="val"/>
               </inlets>
               <outlets>
                  <int32.positive name="int" description="integer positive result"/>
               </outlets>
               <displays/>
               <params>
                  <int32 name="max">
                     <MinValue i="0"/>
                     <MaxValue i="134217727"/>
                  </int32>
               </params>
               <attribs/>
               <includes/>
               <code.declaration><![CDATA[


// Scale input to range out_min > out_max
// Input range hard-coded to 0 > 134217727 (27 bits) for frac32.pos inlets / frac32.u.map params
// WONT'T Work with bipolar input!
__attribute__ ( ( always_inline ) ) __STATIC_INLINE int32_t range_pos(int32_t val, int32_t out_max) {
	return (int32_t)(float)val * (float)out_max / 0x07FFFFFF;
};

]]></code.declaration>
               <code.krate><![CDATA[

outlet_int = range_pos(__USAT(inlet_val, 27), param_max);

]]></code.krate>
            </object>
         </patchobj>
         <obj type="patch/outlet i" uuid="aae2176b26209e34e4fdeba5edb1ace82d178655" name="outlet_1" x="252" y="84">
            <params/>
            <attribs/>
         </obj>
         <nets>
            <net>
               <source obj="Value" outlet="out"/>
               <dest obj="Param Max__" inlet="val"/>
            </net>
            <net>
               <source obj="Param Max__" outlet="int"/>
               <dest obj="outlet_1" inlet="outlet"/>
            </net>
         </nets>
         <settings>
            <subpatchmode>no</subpatchmode>
         </settings>
         <notes><![CDATA[]]></notes>
      </subpatch>
   </patcher>
   <nets>
      <net>
         <source obj="Volume" outlet="out"/>
         <dest obj="*_1" inlet="a"/>
      </net>
      <net>
         <source obj="*_1" outlet="result"/>
         <dest obj="out_1" inlet="left"/>
         <dest obj="out_1" inlet="right"/>
      </net>
      <net>
         <source obj="Talkie Voiced Source" outlet="out"/>
         <dest obj="*_1" inlet="b"/>
      </net>
      <net>
         <source obj="keyb_1" outlet="note"/>
         <dest obj="Talkie Voiced Source" inlet="note"/>
      </net>
      <net>
         <source obj="Period" outlet="outlet_1"/>
         <dest obj="Talkie Voiced Source" inlet="synthPeriod"/>
      </net>
      <net>
         <source obj="Energy" outlet="outlet_1"/>
         <dest obj="Talkie Voiced Source" inlet="synthEnergy"/>
      </net>
   </nets>
   <settings>
      <subpatchmode>no</subpatchmode>
   </settings>
   <notes><![CDATA[]]></notes>
   <windowPos>
      <x>619</x>
      <y>23</y>
      <width>1240</width>
      <height>852</height>
   </windowPos>
</patch-1.0>