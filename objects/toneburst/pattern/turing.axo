<objdefs appVersion="1.0.8">
   <obj.normal id="turing" uuid="f4aa3eb926415b6fc796e993dde554a273a022ac">
      <sDescription>16-Bit Shift-register pattern generator, based on Music Thing Turing machine Eurorack module, with extras</sDescription>
      <author>toneburst</author>
      <license>BSD</license>
      <helpPatch>turing.axh</helpPatch>
      <inlets>
         <int32.positive name="seed" description="Seed value (16 bit integer)"/>
         <frac32.bipolar name="noise" description="Noise Input"/>
         <bool32.rising name="clock" description="Clock Pulse"/>
         <bool32.rising name="reset" description="Reset Pulse"/>
         <bool32.rising name="load" description="Load Seed Bits"/>
         <bool32.rising name="flip" description="Flip Current Bit"/>
      </inlets>
      <outlets>
         <frac32.bipolar name="pattern" description="Pattern Out (Bipolar)"/>
         <int32.positive name="state" description="16-Bit Shift-Register State"/>
         <bool32 name="flip" description="Pulse On Bit-Flip"/>
      </outlets>
      <displays/>
      <params>
         <frac32.s.map name="rand" description="Bit-Flip Threshold" noLabel="true"/>
      </params>
      <attribs/>
      <code.declaration><![CDATA[

// Flip-flop triggers for pulse inputs
int init = 1;
int ctrig = 0;
int rtrig = 0;
int ltrig = 0;
int ftrig = 0;

uint8_t counter = 0;
//int32_t length = 8;
//int32_t offset = 0;
uint16_t baseval = 0;
uint16_t workingval = 0;
uint16_t state = 0;

int32_t outval = 0;
bool flippulse = false;

///////////////////////
// Utility Functions //
///////////////////////

uint16_t rotate_right(uint16_t val, uint8_t shift) {
	return (val << shift) | (val >> (16 - shift));
}

/*uint16_t rotate_left(uint16_t val, uint8_t shift) {
	return (val << (16 - shift)) | (val >> shift);
}*/

// http://stackoverflow.com/questions/47981/how-do-you-set-clear-and-toggle-a-single-bit-in-c-c

// Toggle bit X
uint16_t togglebitx(uint16_t val, uint8_t x) {
	return val ^= 1 << x;
}

// Get values of left-hand 8 bytes of 16bit int (other bits zeroed)
uint16_t getleftbyte(uint16_t word) {
    return word >> 8;
}

// Get values of right-hand 8 bytes of 16bit int (other bits zeroed)
uint16_t getrightbyte(uint16_t word) {
    return (word << 8) >> 8;
}


           ]]></code.declaration>
      <code.krate><![CDATA[

///////////////////////////////
// Loop Running For 1st Time //
///////////////////////////////

if (init == 1) {
	baseval = inlet_seed;
	workingval = baseval;
	init = 0;
}

///////////////
// Load Seed //
///////////////

if ((inlet_load > 0) && !ltrig) {
	baseval = inlet_seed;
	workingval = baseval;
	ltrig = 1;
} else if (!(inlet_load > 0)) {
	ltrig = 0;
}

/////////////////////////////
// Reset Input Rising Edge //
/////////////////////////////

if ((inlet_reset > 0) && !rtrig) {
	counter = 0;
	rtrig = 1;
} else if (!(inlet_reset > 0)) {
	rtrig = 0;
}

////////////////////////////////////////
// Flip Current First Bit Rising Edge //
////////////////////////////////////////

if ((inlet_flip > 0) && !ftrig) {
    workingval = togglebitx(workingval, counter);
	ftrig = 1;
} else if (!(inlet_flip > 0)) {
	ftrig = 0;
}

/////////////////////////////
// Clock Input Rising Edge //
/////////////////////////////

if ((inlet_clock > 0) && !ctrig) {

    if (inlet_noise < param_rand) {
        workingval = togglebitx(workingval, counter);
        flippulse = true;
    }

    state = rotate_right(workingval, counter);
    outval = (state >> 8) - 128;

	// Update counter
	counter = (counter < 16) ? counter + 1 : 0;

	ctrig = 1;

} else if (inlet_clock == 0) {
    flippulse = false;
    ctrig = 0;
}

////////////////////
// Pattern Output //
////////////////////

outlet_pattern = outval << 20;
outlet_state = state;
outlet_flip = flippulse;


    ]]></code.krate>
   </obj.normal>
</objdefs>
